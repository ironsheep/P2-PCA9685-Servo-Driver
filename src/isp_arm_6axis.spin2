'' =================================================================================================
''
''   File....... isp_arm_6axis.spin2
''   Purpose.... Methods for moving our 6-axis arm
''   Authors.... Stephen M Moraco
''               -- Copyright (c) 2021 Iron Sheep Productions, LLC
''               -- see below for terms of use
''   E-mail..... stephen@ironsheep.biz
''   Started.... Jun 2021
''   Updated.... 06 Jun 2021
''
'' =================================================================================================

CON { arm specifics }

MAX_SERVOS = 8

' which servos are on which PWM channels?
#0, CHAN_SERVO_BASE, CHAN_SERVO_SHOULDER, CHAN_SERVO_ELBOW
#4, CHAN_SERVO_WRIST_FLEX, CHAN_SERVO_WRIST_ROTATE, CHAN_SERVO_GRIP

CHAN_SERVO_TEST_15 = 15
CHAN_SERVO_TEST_12 = 12

' servo object indexes
#0, SERVO_BASE, SERVO_SHOULDER, SERVO_ELBOW
#3, SERVO_WRIST_FLEX, SERVO_WRIST_ROTATE, SERVO_GRIP
#6, SERVO_TEST_12, SERVO_TEST_15

HOME_SERVO_BASE = 90
HOME_SERVO_SHOULDER = 110   ' vertical !!
HOME_SERVO_ELBOW = 90
HOME_SERVO_WRIST_FLEX = 90
HOME_SERVO_WRIST_ROTATE = 90
HOME_SERVO_GRIP = 90

HOME_SERVO_TEST_12 = 90
HOME_SERVO_TEST_15 = 180

DEFAULT_SERVO_MAX = 2200
DEFAULT_SERVO_CENTER = 1500
DEFAULT_SERVO_MIN = 800


DEFAULT_GRIP_SERVO_MAX = 1722
DEFAULT_GRIP_SERVO_MIN = 1110

#0, MO_NONE, MO_ELBO, MO_VERTICAL, MO_BOT_DOWN, MO_TOP_DOWN, MO_RT_DOWN, MO_FRONT_DOWN, MO_LT_DOWN, MO_BACK_DOWN, MO_ARM_CANTELEVER_F, MO_ARM_CANTELEVER_B

#0, FLT_NONE, FLT_ROLL, FLT_PITCH, FLT_YAW

OBJ { our objects }

    servos[MAX_SERVOS]  : "isp_i2c_pca9685_servo"               ' our six servos
    term                : "isp_jm_serial_singleton"                 ' terminal output

pub null()

'' This is not a top-level object

pub start() : ok | angle
    '' configure controller then home all arm servos
    'term.fstr0(string("** start() ENTRY\r\n"))

    initArmServos()

    homeArm()
    waitms(3000)   ' hold for 3 secs

    term.fstr0(string("** start() EXIT\r\n"))
    'repeat  ' just stall here

PUB homeArm()
    '' place the arm completely upright
    term.fstr0(string("** homeArm()\r\n"))
    servos[SERVO_BASE].writePosition(servos.M_ANGLE, HOME_SERVO_BASE)
    servos[SERVO_SHOULDER].writePosition(servos.M_ANGLE, HOME_SERVO_SHOULDER)
    servos[SERVO_ELBOW].writePosition(servos.M_ANGLE, HOME_SERVO_ELBOW)
    servos[SERVO_WRIST_FLEX].writePosition(servos.M_ANGLE, HOME_SERVO_WRIST_FLEX)
    servos[SERVO_WRIST_ROTATE].writePosition(servos.M_ANGLE, HOME_SERVO_WRIST_ROTATE)
    servos[SERVO_GRIP].writePosition(servos.M_ANGLE, servos[SERVO_GRIP].centerMicroSec())
    ' wait for servos to arrive at target positions
    waitms(500)    ' sleep 1/2 seconds


PUB position(moVar) : bDidMove
    '' tell arm to move to specific position
    bDidMove := FALSE
'#0, MO_NONE, MO_ELBO, MO_VERTICAL, MO_BOT_DOWN, MO_TOP_DOWN, MO_RT_DOWN, MO_FRONT_DOWN, MO_LT_DOWN, MO_BACK_DOWN, MO_ARM_CANTELEVER_F, MO_ARM_CANTELEVER_B
    case moVar
        MO_ELBO:
            'armFlatForwardYellowUp()
            'bDidMove := TRUE
        MO_VERTICAL:
            'armHomeVertical()
            'bDidMove := TRUE
        MO_BOT_DOWN:                    '  YELLLOW UP / GREEN DOWN - OFF a bit
            armFlatForwardYellowUp()
            bDidMove := TRUE
        MO_TOP_DOWN:                    '  GREEN UP / YELLLOW DOWN
            armFlatBackGreenUp()
            bDidMove := TRUE
        MO_RT_DOWN:                     '  ORANGE UP / RED DOWN  - tilted forward, tilted right
            armFlatForwardOrangeUp()
            bDidMove := TRUE
        MO_FRONT_DOWN:                  '  CYAN UP / PURPLE DOWN
            armVertCyanUp()
            bDidMove := TRUE
        MO_LT_DOWN:                     '  RED UP / RED ORANGE  - tiled right
            armFlatBackRedUp()              ' GOOD
            bDidMove := TRUE
        MO_BACK_DOWN:                   '  PURPLE UP / CYAN DOWN
        MO_ARM_CANTELEVER_F:
            'armFlatForward()
            'bDidMove := TRUE
        MO_ARM_CANTELEVER_B:
            'armFlatBack()
            'armFlatBackYellowUp()
            'bDidMove := TRUE
        other:
            bDidMove := FALSE


PUB demoPositions(loopCt) | moValue, bDidMove
    '' demo all defined postions in loop, {loopCt} times
    term.fstr1(string("** demoPositions(%d)\r\n"), loopCt)
    if loopCt < 1
        loopCt := 1

    repeat loopCt
        repeat moValue from MO_ELBO to MO_ARM_CANTELEVER_B
            bDidMove := position(moValue)
            if bDidMove
                waitms(3000)   ' hold for 10 secs

    armHomeVertical()

{
    repeat
        servos[SERVO_TEST_15].write(servos.M_USECS, 900)
        waitms(1000)
        servos[SERVO_TEST_15].write(servos.M_USECS, 1500)
        waitms(1000)
        servos[SERVO_TEST_15].write(servos.M_USECS, 2200)
        waitms(1000)


    repeat
        repeat angle from 0 to 180 step 20
            waitms(500)
            servos[SERVO_TEST_15].write(servos.M_ANGLE, angle)
            waitms(200)

        waitms(1000)
        servos[SERVO_TEST_15].write(servos.M_ANGLE, 0)

    term.fstr0(string("** doServoSteps() EXIT\r\n"))
'}

    ' -----------------------------------------------------------------
    ' calibrate clock... pulse width
    {
    'servos[SERVO_TEST_12].start(CHAN_SERVO_TEST_12, HOME_SERVO_TEST_12)
    servos[SERVO_TEST_15].start(CHAN_SERVO_TEST_15, HOME_SERVO_TEST_15)
    waitms(8000)
    servos[SERVO_TEST_15].write(servos.M_ANGLE, 0)
    waitms(8000)

    servos[SERVO_TEST_15].write(servos.M_USECS, 800)
    waitms(8000)
    servos[SERVO_TEST_15].write(servos.M_USECS, 1500)
    waitms(8000)
    servos[SERVO_TEST_15].write(servos.M_USECS, 2200)

    repeat
    '}
    ' -----------------------------------------------------------------

PRI initArmServos()
    ' configure all the servo objects with channel and limits specific to each
    term.fstr0(string("** initArmServos()\r\n"))
    servos[SERVO_BASE].configureMinCtrMaxType(DEFAULT_SERVO_MIN, DEFAULT_SERVO_CENTER, DEFAULT_SERVO_MAX, servos.ST_360_DEGREE)
    servos[SERVO_BASE].init(CHAN_SERVO_BASE, servos.M_NOT_SET, 0, string("Base"))
    servos[SERVO_BASE].enableDebug(TRUE)

    servos[SERVO_SHOULDER].configureMinCtrMaxType(DEFAULT_SERVO_MIN, DEFAULT_SERVO_CENTER, DEFAULT_SERVO_MAX, servos.ST_STANDARD)
    servos[SERVO_SHOULDER].init(CHAN_SERVO_SHOULDER, servos.M_NOT_SET, 0, string("Shldr"))
    servos[SERVO_SHOULDER].enableDebug(TRUE)

    servos[SERVO_ELBOW].configureMinCtrMaxType(DEFAULT_SERVO_MIN, DEFAULT_SERVO_CENTER, DEFAULT_SERVO_MAX, servos.ST_STANDARD)
    servos[SERVO_ELBOW].init(CHAN_SERVO_ELBOW, servos.M_NOT_SET, 0, string("Elbow"))
    servos[SERVO_ELBOW].enableDebug(TRUE)

    servos[SERVO_WRIST_FLEX].configureMinCtrMaxType(DEFAULT_SERVO_MIN, DEFAULT_SERVO_CENTER, DEFAULT_SERVO_MAX, servos.ST_STANDARD)
    servos[SERVO_WRIST_FLEX].init(CHAN_SERVO_WRIST_FLEX, servos.M_NOT_SET, 0, string("WrFlex"))
    servos[SERVO_WRIST_FLEX].enableDebug(TRUE)

    servos[SERVO_WRIST_ROTATE].configureMinCtrMaxType(DEFAULT_SERVO_MIN, DEFAULT_SERVO_CENTER, DEFAULT_SERVO_MAX, servos.ST_STANDARD)
    servos[SERVO_WRIST_ROTATE].init(CHAN_SERVO_WRIST_ROTATE, servos.M_NOT_SET, 0, string("WrRota"))
    servos[SERVO_WRIST_ROTATE].enableDebug(TRUE)

    servos[SERVO_GRIP].configureMinCtrMaxType(DEFAULT_GRIP_SERVO_MIN, servos.CALCULATE_CENTER, DEFAULT_GRIP_SERVO_MAX, servos.ST_STANDARD)
    servos[SERVO_GRIP].init(CHAN_SERVO_GRIP, servos.M_NOT_SET, 0, string("Grip"))
    servos[SERVO_GRIP].enableDebug(TRUE)


PRI armHomeVertical()
    ' place the arm completely upright
    term.fstr0(string("** armHomeVertical() SLEW\r\n"))
    servos[SERVO_BASE].slewToPostion(servos.M_ANGLE, HOME_SERVO_BASE)
    servos[SERVO_SHOULDER].slewToPostion(servos.M_ANGLE, HOME_SERVO_SHOULDER)
    servos[SERVO_ELBOW].slewToPostion(servos.M_ANGLE, HOME_SERVO_ELBOW + 5)     ' 90 + 5 = 95
    servos[SERVO_WRIST_FLEX].slewToPostion(servos.M_ANGLE, HOME_SERVO_WRIST_FLEX)
    servos[SERVO_WRIST_ROTATE].slewToPostion(servos.M_ANGLE, HOME_SERVO_WRIST_ROTATE)
    servos[SERVO_GRIP].slewToPostion(servos.M_ANGLE, servos[SERVO_GRIP].centerMicroSec())
    ' wait for servos to arrive at target positions
    continueSlewingUntilDone()

PUB gripClosed()
    ' close the jaws
    term.fstr0(string("** gripClosed()\r\n"))
    'term.fstr0(string("** gripClosed() SLEW\r\n"))
    servos[SERVO_GRIP].writePosition(servos.M_USECS, DEFAULT_GRIP_SERVO_MIN)

PUB gripOpen()
    '' Open the jaws
    'term.fstr0(string("** gripOpen() SLEW\r\n"))
    term.fstr0(string("** gripOpen()\r\n"))
    servos[SERVO_GRIP].writePosition(servos.M_USECS, DEFAULT_GRIP_SERVO_MAX)

PUB positionServo(eServo, valueInUSec, minRange, maxRange) | servoIndex, newPosnUSec
    '' Move servo to specified position (limited by its own range)
    servoIndex := SERVO_BASE #> eServo <# SERVO_GRIP   ' must be one of our 6 servos
    newPosnUSec:= servos[servoIndex].mapValueToServoPosnInUSec(valueInUSec, minRange, maxRange)
    servos[servoIndex].writePosition(servos.M_USECS, newPosnUSec)

PRI armFlatForwardYellowUp()
    ' place the arm bent at 90 degr overhanging base
    ' YELLOW UP
    term.fstr0(string("** armFlatForwardYellowUp() SLEW\r\n"))
    servos[SERVO_BASE].slewToPostion(servos.M_ANGLE, HOME_SERVO_BASE)
    servos[SERVO_SHOULDER].slewToPostion(servos.M_ANGLE, HOME_SERVO_SHOULDER)
    servos[SERVO_ELBOW].slewToPostion(servos.M_ANGLE, 8)
    servos[SERVO_WRIST_FLEX].slewToPostion(servos.M_ANGLE, HOME_SERVO_WRIST_FLEX)
    servos[SERVO_WRIST_ROTATE].slewToPostion(servos.M_ANGLE, HOME_SERVO_WRIST_ROTATE + 10)   ' 90 + 10 = 100
    servos[SERVO_GRIP].slewToPostion(servos.M_ANGLE, servos[SERVO_GRIP].centerMicroSec())
    ' wait for servos to arrive at target positions
    continueSlewingUntilDone()

PRI armFlatForwardOrangeUp()
    ' arm flat 2nd means
    ' ORANGE UP
    term.fstr0(string("** armFlatForwardOrangeUp() SLEW\r\n"))
    ' 1700 low
    servos[SERVO_SHOULDER].slewToPostion(servos.M_USECS, 1650)
    servos[SERVO_ELBOW].slewToPostion(servos.M_USECS, 900)
    servos[SERVO_WRIST_ROTATE].slewToPostion(servos.M_USECS, 850)   ' Orig 900
    ' wait for servos to arrive at target positions
    continueSlewingUntilDone()

PRI armFlatForwardRedUp()
    ' arm flat 2nd means - grip inverted
    ' RED UP
    term.fstr0(string("** armFlatForwardRedUp() SLEW\r\n"))
    ' 1700 low
    servos[SERVO_SHOULDER].slewToPostion(servos.M_USECS, 1650)
    servos[SERVO_ELBOW].slewToPostion(servos.M_USECS, 800)
    servos[SERVO_WRIST_ROTATE].slewToPostion(servos.M_USECS, 2300)
    ' wait for servos to arrive at target positions
    continueSlewingUntilDone()

{
PRI armFlatForwardPurpleUp()
    ' arm flat 2nd means - grip ??
    ' PURPLE UP
    term.fstr0(string("** armFlatForwardPurpleUp() SLEW\r\n"))
    ' 1700 low
    servos[SERVO_SHOULDER].slewToPostion(servos.M_USECS, 1650)
    servos[SERVO_ELBOW].slewToPostion(servos.M_USECS, 800)
    servos[SERVO_WRIST_ROTATE].slewToPostion(servos.M_USECS, 1500)
    ' wait for servos to arrive at target positions
    continueSlewingUntilDone()
'}

PRI armVertCyanUp()
    ' CYAN UP
    term.fstr0(string("** armVertCyanUp() SLEW\r\n"))
    servos[SERVO_SHOULDER].slewToPostion(servos.M_USECS, 1650)
    servos[SERVO_ELBOW].slewToPostion(servos.M_USECS, 1800)
    servos[SERVO_WRIST_ROTATE].slewToPostion(servos.M_USECS, 2200)
    ' wait for servos to arrive at target positions
    continueSlewingUntilDone()

PRI armFlatBack()
    ' arm flat 1st means
    term.fstr0(string("** armFlatBack() SLEW\r\n"))
    servos[SERVO_SHOULDER].slewToPostion(servos.M_USECS, 1420)
    servos[SERVO_ELBOW].slewToPostion(servos.M_USECS, 2200)
    ' wait for servos to arrive at target positions
    continueSlewingUntilDone()

{
PRI armFlatBackOrangeUp()
    ' arm flat 1st means
    ' ORANGE UP
    term.fstr0(string("** armFlatBackOrangeUp() SLEW\r\n"))
    servos[SERVO_SHOULDER].slewToPostion(servos.M_USECS, 1420)
    servos[SERVO_ELBOW].slewToPostion(servos.M_USECS, 2200)
    servos[SERVO_WRIST_ROTATE].slewToPostion(servos.M_USECS, 900)
    ' wait for servos to arrive at target positions
    continueSlewingUntilDone()
'}

PRI armFlatBackRedUp()
    ' arm flat 1st means
    ' RED UP
    term.fstr0(string("** armFlatBackRedUp() SLEW\r\n"))
    servos[SERVO_SHOULDER].slewToPostion(servos.M_USECS, 1420)
    servos[SERVO_ELBOW].slewToPostion(servos.M_USECS, 2200)
    servos[SERVO_WRIST_ROTATE].slewToPostion(servos.M_USECS, 800)   ' 2300 -> 800 when back
    ' wait for servos to arrive at target positions
    continueSlewingUntilDone()

PRI armFlatBackGreenUp()
    ' arm flat 1st means
    term.fstr0(string("** armFlatBackGreenUp() SLEW\r\n"))
    servos[SERVO_SHOULDER].slewToPostion(servos.M_USECS, 1420)
    servos[SERVO_ELBOW].slewToPostion(servos.M_USECS, 2200)
    servos[SERVO_WRIST_ROTATE].slewToPostion(servos.M_USECS, 1550)  ' orig 1500
    ' wait for servos to arrive at target positions
    continueSlewingUntilDone()


PRI armFlatForward()
    ' arm flat 2nd means
    term.fstr0(string("** armFlatForward() SLEW\r\n"))
    ' 1700 low
    servos[SERVO_SHOULDER].slewToPostion(servos.M_USECS, 1650)
    servos[SERVO_ELBOW].slewToPostion(servos.M_USECS, 800)
    ' wait for servos to arrive at target positions
    continueSlewingUntilDone()

PRI continueSlewingUntilDone() | bSlewComplete, servoIndex, bDidMove
    ' tell any servos not at target to continue to next position...
    repeat
        bDidMove := FALSE
        repeat servoIndex from SERVO_BASE to SERVO_GRIP
            if not servos[servoIndex].isAtPostion()
                servos[servoIndex].continueSlew()
                bDidMove := TRUE
        if bDidMove
            waitms(10)    ' 25 sorta ok, trying 10
            bSlewComplete := allServosAtTarget()
    while not bSlewComplete


PRI allServosAtTarget() : bAtTArgetStatus | servoIndex, bDoneStatus
    bAtTArgetStatus := TRUE
    repeat servoIndex from SERVO_BASE to SERVO_GRIP
        bDoneStatus := servos[servoIndex].isAtPostion()
        if not bDoneStatus
            bAtTArgetStatus := FALSE
            quit    ' outta here, we know our answer
    if bAtTArgetStatus
        term.fstr0(string("** allServosAtTarget() DONE\r\n"))
    else
        term.fstr0(string("** allServosAtTarget() waiting...\r\n"))


PUB doServoSteps() | angle
    ' for( int angle =0; angle<181; angle +=20) {
    '    delay(500);
    '    pwm.setPWM(0, 0, angleToPulse(angle)
    ' };
    term.fstr0(string("** doServoSteps() ENTRY\r\n"))
    repeat
        repeat angle from 0 to 180 step 20
            waitms(500)
            servos[SERVO_TEST_15].writePosition(servos.M_ANGLE, angle)
        waitms(1000)

    term.fstr0(string("** doServoSteps() EXIT\r\n"))




CON { license }

{{
 -------------------------------------------------------------------------------------------------
  MIT License

  Copyright (c) 2021 Iron Sheep Productions, LLC

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
 =================================================================================================
}}
